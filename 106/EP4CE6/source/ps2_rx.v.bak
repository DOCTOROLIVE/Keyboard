module ps2_rx(
	input clock_quarter, reset, start,
	output[7:0] buffer,
	inout PS2_CLK, PS2_DAT
);

/*****************************************************************************
 *                           Parameter Declarations                          *
 *****************************************************************************/
localparam 
	IDEL   = 6'b000001,
    START  = 6'b000010,
	DATA   = 6'b000100,
	PARITY = 6'b001000,
	STOP   = 6'b010000,
	ACK    = 6'b100000;

/*****************************************************************************
 *                           REG/WIRE Declarations                           *
 *****************************************************************************/

reg[5:0] curr_state, next_state;
reg[2:0] byte_cnt;  // 8 bits/byte
reg[1:0] bit_cnt;  // 4 states/bit
reg start_bit, clk_sync, dat_sync;

wire bit_finish = bit_cnt == 2'b11;

/*****************************************************************************
 *                            Combinational logic                            *
 *****************************************************************************/

 
/*****************************************************************************
 *                             Sequential logic                              *
 *****************************************************************************/

always @(posedge clock_quarter)
	begin
	  	clk_sync <= PS2_CLK;
		dat_sync <= PS2_DAT;
	end

always @ (posedge clock_quarter)
	if (curr_state != IDEL)
		bit_cnt = bit_cnt + 1;
	else
		bit_cnt = 0;

always @ (posedge clock_quarter)
	if (curr_state != DATA)
		byte_cnt = 0;
	else if (bit_finish)
		byte_cnt = byte_cnt + 1;
	else
		byte_cnt = byte_cnt;

always @(posedge clock_quarter)
	if (curr_state == DATA)
		buffer[byte_cnt] = dat_sync;
	else if (curr_state == START)
		buffer = 8'h0;
	else
		buffer = buffer;

/*****************************************************************************
 *                         Finite State Machine(s)                           *
 *****************************************************************************/
always @ (posedge clock_quarter, posedge reset)
	if (reset)
		curr_state = IDEL; 
	else
		curr_state = next_state;
		
always @ *
	case (curr_state)
		IDEL: 
			if (start)
				next_state <= START;
			else
				next_state <= IDEL;
		START:
			if (clk_sync && !dat_sync)
				next_state <= DATA;
			else
				next_state <= START;
		DATA:
			if (byte_cnt == 3'd7 && bit_finish)
				next_state <= PARITY;
			else
				next_state <= DATA;
		PARITY:
			if (bit_finish)
			 	next_state <= STOP;
			else
				next_state <= PARITY;
		STOP:
			if (bit_finish)
				next_state <= ACK;
			else
				next_state <= STOP;
		ACK:
			next_state <= IDEL;
		default: next_state <= IDEL;
	endcase

endmodule
